<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>×¤×™×œ×˜×¨ ×¦×‘×¢×™ ×¢×™× ×™×™× (××¡×•××Ÿ) â€“ blink gating</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
</head>
<body>
<div id="eye-filter-widget" style="max-width: 800px; margin: 24px auto; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;">
  <style>
    #eye-filter-widget * { box-sizing: border-box; }
    .efw-card{border:1px solid #e5e7eb;border-radius:16px;padding:20px;box-shadow:0 4px 24px rgba(0,0,0,0.1);background:#fff;direction:rtl}
    .efw-row{display:grid;grid-template-columns:1fr;gap:20px}
    @media (min-width:720px){.efw-row{grid-template-columns:1fr 320px}}
    .efw-video-wrap{position:relative;width:100%;aspect-ratio:4/3;background:linear-gradient(135deg,#1e293b,#334155);border-radius:12px;overflow:hidden;box-shadow:0 4px 16px rgba(0,0,0,0.2)}
    #efw-canvas{width:100%;height:100%;display:block;border-radius:12px}
    video#efw-video{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;opacity:0;pointer-events:none}
    .efw-ctrls{display:grid;gap:16px;align-content:start}
    .efw-group{border:1px solid #e5e7eb;border-radius:12px;padding:16px;background:#f8fafc}
    .efw-label{display:block;font-size:14px;color:#1e293b;margin-bottom:8px;font-weight:600}
    .efw-inline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .efw-chip{width:28px;height:28px;border-radius:50%;border:2px solid #cbd5e1;cursor:pointer;transition:all .2s ease;box-shadow:0 2px 4px rgba(0,0,0,.1)}
    .efw-chip:hover{transform:scale(1.1);border-color:#475569}
    .efw-chip.active{border-color:#0ea5e9;box-shadow:0 0 0 2px rgba(14,165,233,.2)}
    .efw-btn{appearance:none;border:1px solid #0f172a;background:#0f172a;color:#fff;padding:12px 16px;border-radius:10px;cursor:pointer;font-weight:600;transition:all .2s ease;font-size:14px}
    .efw-btn:hover{background:#1e293b;transform:translateY(-1px)}
    .efw-btn.sec{background:#fff;color:#0f172a;border-color:#cbd5e1}
    .efw-btn.sec:hover{background:#f1f5f9}
    .efw-btn:disabled{opacity:.6;cursor:not-allowed;transform:none}
    .efw-small{font-size:12px;color:#64748b;line-height:1.4}
    .efw-status-bad{color:#dc2626;font-weight:600}
    .efw-status-ok{color:#059669;font-weight:600}
    .efw-slider{width:100%;margin:8px 0}
    .efw-status{margin-top:12px;min-height:24px;white-space:pre-line;padding:8px;background:#f8fafc;border-radius:8px;border:1px solid #e2e8f0}
    .efw-color-input{width:40px;height:40px;border:none;border-radius:8px;cursor:pointer}
    select{padding:8px;border-radius:8px;border:1px solid #cbd5e1;background:#fff;font-size:14px}
    .loading-dot{display:inline-block;width:8px;height:8px;border-radius:50%;background:#0ea5e9;margin:0 2px;animation:loading 1.4s infinite ease-in-out both}
    .loading-dot:nth-child(1){animation-delay:-.32s}
    .loading-dot:nth-child(2){animation-delay:-.16s}
    @keyframes loading{0%,80%,100%{transform:scale(0)}40%{transform:scale(1)}}
  </style>

  <div class="efw-card">
    <div class="efw-row">
      <div>
        <div class="efw-video-wrap">
          <canvas id="efw-canvas"></canvas>
          <video id="efw-video" playsinline autoplay muted></video>
        </div>
        <div id="efw-status" class="efw-status efw-small">×œ×—×¥ ×¢×œ "×”×¤×¢×œ ××¦×œ××”" ×œ×”×ª×—×œ×”</div>
      </div>

      <div class="efw-ctrls">
        <div class="efw-group">
          <label class="efw-label">×”×¤×¢×œ×”</label>
          <div class="efw-inline">
            <button id="efw-start" class="efw-btn">×”×¤×¢×œ ××¦×œ××”</button>
            <button id="efw-stop" class="efw-btn sec" disabled>×¢×¦×•×¨</button>
          </div>
          <div class="efw-small">×“×¨×•×© HTTPS ××• localhost ×œ×’×™×©×” ×œ××¦×œ××”</div>
        </div>

        <div class="efw-group">
          <label class="efw-label">×‘×—×™×¨×ª ×¦×‘×¢ ×¢×™× ×™×™×</label>
          <div class="efw-inline">
            <input id="efw-color" class="efw-color-input" type="color" value="#b7a49d" aria-label="×‘×—×¨ ×¦×‘×¢" />
            <div class="efw-inline">
              <div class="efw-chip active" data-color="#b7a49d" title="Dune" style="background:#b7a49d"></div>
              <div class="efw-chip" data-color="#79655a" title="Sand ER19D" style="background:#79655a"></div>
              <div class="efw-chip" data-color="#947d51" title="Honey Gold" style="background:#947d51"></div>
              <div class="efw-chip" data-color="#947d51" title="Sahara" style="background:#947d51"></div>
              <div class="efw-chip" data-color="#998a69" title="Tropical" style="background:#998a69"></div>
              <div class="efw-chip" data-color="#8e9988" title="Savana" style="background:#8e9988"></div>
              <div class="efw-chip" data-color="#657960" title="Pistache CT88" style="background:#657960"></div>
              <div class="efw-chip" data-color="#abc0ad" title="Jade" style="background:#abc0ad"></div>
              <div class="efw-chip" data-color="#d5e4df" title="Arctique" style="background:#d5e4df"></div>
              <div class="efw-chip" data-color="#a1bccf" title="Green Water" style="background:#a1bccf"></div>
              <div class="efw-chip" data-color="#9bacbe" title="Turquoise" style="background:#9bacbe"></div>
              <div class="efw-chip" data-color="#8298c7" title="New Blue" style="background:#8298c7"></div>
              <div class="efw-chip" data-color="#7785a8" title="Pacific" style="background:#7785a8"></div>
              <div class="efw-chip" data-color="#c4d5ff" title="Azur" style="background:#c4d5ff"></div>
              <div class="efw-chip" data-color="#e6ebff" title="Polar Grey" style="background:#e6ebff"></div>
              <div class="efw-chip" data-color="#aeb2bd" title="Pearl" style="background:#aeb2bd"></div>
            </div>
          </div>

          <div style="margin-top:12px;">
            <label class="efw-label">×¢×•×¦××ª ×”×¦×‘×¢</label>
            <input id="efw-alpha" class="efw-slider" type="range" min="10" max="100" value="65" />
            <div class="efw-small">×¢×•×¦××”: <span id="efw-alpha-val">65</span>%</div>
          </div>

          <div style="margin-top:12px;">
            <label class="efw-label">××™×–×• ×¢×™×Ÿ ×œ×¦×‘×•×¢</label>
            <div class="efw-inline">
              <label style="font-weight: normal;"><input type="checkbox" id="efw-left" checked> ×¢×™×Ÿ ×©×××œ</label>
              <label style="font-weight: normal;"><input type="checkbox" id="efw-right" checked> ×¢×™×Ÿ ×™××™×Ÿ</label>
            </div>
          </div>

          <div style="margin-top:12px;">
            <label class="efw-label">××¦×‘ ×¢×¨×‘×•×‘ ×¦×‘×¢×™×</label>
            <select id="efw-blend">
              <option value="multiply">Multiply (××•××œ×¥)</option>
              <option value="screen">Screen</option>
              <option value="overlay">Overlay</option>
              <option value="color">Color</option>
              <option value="source-over">×¨×’×™×œ</option>
            </select>
          </div>
        </div>

        <div class="efw-group">
          <label class="efw-label">××™×“×¢ ×˜×›× ×™</label>
          <div class="efw-small" id="efw-help">××©×ª××© ×‘-MediaPipe FaceMesh ×œ×–×™×”×•×™ ×¤× ×™× ××“×•×™×§</div>
          <div class="efw-small" style="margin-top: 8px;">
            FPS: <span id="efw-fps">0</span> | ×¤× ×™×: <span id="efw-faces">0</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  (function(){
    'use strict';

    const video = document.getElementById('efw-video');
    const canvas = document.getElementById('efw-canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const statusEl = document.getElementById('efw-status');
    const helpEl = document.getElementById('efw-help');
    const fpsEl = document.getElementById('efw-fps');
    const facesEl = document.getElementById('efw-faces');

    const btnStart = document.getElementById('efw-start');
    const btnStop  = document.getElementById('efw-stop');
    const colorInp = document.getElementById('efw-color');
    const alphaInp = document.getElementById('efw-alpha');
    const alphaVal = document.getElementById('efw-alpha-val');
    const leftChk  = document.getElementById('efw-left');
    const rightChk = document.getElementById('efw-right');
    const blendSel = document.getElementById('efw-blend');
    try { blendSel.value = 'color'; } catch(_) {}

    let running = false;
    let stream = null;
    let faceMesh = null;
    let animationId = null;
    let currentEyes = { left: null, right: null };
    let currentLogo = null;
    let currentEyelids = { left: null, right: null };
    let lastTime = 0;
    let frameCount = 0;
    let fpsCounter = 0;

    const REALISM = {
      SIZE_MULTIPLIER: 0.92,
      MIN_RADIUS: 6,
      MAX_RADIUS: 36,
      IRIS_SHRINK: 0.90,
      RING_MARGIN: 0.92,
      PUPIL_RATIO: 0.32,
      LIMBAL_WIDTH: 0.18,
      LIMBAL_ALPHA: 0.55,
      HIGHLIGHT_ALPHA: 0.35,
      HIGHLIGHT_OFFSET: 0.28,
      FIBER_COUNT: 36,
      FIBER_ALPHA: 0.14,
      FIBER_INNER: 0.28,
      FIBER_OUTER: 0.95,
      EDGE_DARKEN: 0.25,
      INNER_GLOW: 0.20,
      SMOOTHING: 0.35,
      CENTER_BLEND: 0.6,
      CENTER_Y_OFFSET: -0.06,
      FIBER_JITTER: 0.06,
      FIBER_LIGHT_ALPHA: 0.06,
      FIBER_CLEAR_COUNT: 0,
      FIBER_CLEAR_ALPHA: 0,
      FIBER_CLEAR_THICKNESS: 0.5,
      FIBER_CLEAR_INNER: 0.20,
      FIBER_CLEAR_OUTER: 0.97,
      BAND_COUNT: 4,
      BAND_ALPHA: 0.06,
      FILL_BOOST_ALPHA: 0.12
    };

    const EYELID_MASK = {
      ENABLED: true,
      CLIP_STRENGTH: 0.55,
      BLUR_PX: 1.4
    };

    const BLINK = { T0: 0.14, T1: 0.22 }; // ×¨××¤×”: ××ª×—×ª ×œ-T0 × ×›×‘×”, ×‘×™×Ÿ T0 ×œ-T1 ×“×•×¢×š, ××¢×œ T1 ××œ×

    const BRAND = {
      text: "Kerato.Lifeï¸ğŸ‘",
      minFont: 14,
      maxFont: 34,
      offsetYFactor: 0.62,
      alpha: 0.95,
      fill: "#ffffff",
      stroke: "#0f172a",
      strokeWidth: 4,
      shadowBlur: 8
    };

    const noiseCanvas = document.createElement('canvas');
    const noiseCtx = noiseCanvas.getContext('2d');
    noiseCanvas.width = 64; noiseCanvas.height = 64;
    (function buildNoise(){
      const img = noiseCtx.createImageData(noiseCanvas.width, noiseCanvas.height);
      for (let i=0; i<img.data.length; i+=4){
        const v = 120 + Math.floor(Math.random()*16);
        img.data[i] = v; img.data[i+1] = v; img.data[i+2] = v; img.data[i+3] = 10;
      }
      noiseCtx.putImageData(img, 0, 0);
    })();

    const eyeColorLayer = document.createElement('canvas');
    const eyeColorCtx = eyeColorLayer.getContext('2d');
    const eyeShadeLayer = document.createElement('canvas');
    const eyeShadeCtx = eyeShadeLayer.getContext('2d');
    function ensureEyeLayersSize(size){
      const s = Math.max(16, Math.ceil(size));
      if (eyeColorLayer.width !== s || eyeColorLayer.height !== s){ eyeColorLayer.width = s; eyeColorLayer.height = s; }
      if (eyeShadeLayer.width !== s || eyeShadeLayer.height !== s){ eyeShadeLayer.width = s; eyeShadeLayer.height = s; }
      eyeColorCtx.clearRect(0,0,s,s);
      eyeShadeCtx.clearRect(0,0,s,s);
    }

    const eyeMaskLayer = document.createElement('canvas');
    const eyeMaskCtx = eyeMaskLayer.getContext('2d');
    const eyeMaskFeather = document.createElement('canvas');
    const eyeMaskFeatherCtx = eyeMaskFeather.getContext('2d');
    const eyeCutLayer = document.createElement('canvas');
    const eyeCutCtx = eyeCutLayer.getContext('2d');
    const eyeCutFeather = document.createElement('canvas');
    const eyeCutFeatherCtx = eyeCutFeather.getContext('2d');
    function ensureMaskSize(size){
      const s = Math.max(16, Math.ceil(size));
      if (eyeMaskLayer.width !== s || eyeMaskLayer.height !== s){ eyeMaskLayer.width = s; eyeMaskLayer.height = s; }
      if (eyeMaskFeather.width !== s || eyeMaskFeather.height !== s){ eyeMaskFeather.width = s; eyeMaskFeather.height = s; }
      if (eyeCutLayer.width !== s || eyeCutLayer.height !== s){ eyeCutLayer.width = s; eyeCutLayer.height = s; }
      if (eyeCutFeather.width !== s || eyeCutFeather.height !== s){ eyeCutFeather.width = s; eyeCutFeather.height = s; }
      eyeMaskCtx.clearRect(0,0,s,s);
      eyeMaskFeatherCtx.clearRect(0,0,s,s);
      eyeCutCtx.clearRect(0,0,s,s);
      eyeCutFeatherCtx.clearRect(0,0,s,s);
    }

    const testCtx = document.createElement('canvas').getContext('2d');
    const BLEND_SUPPORT = {};
    ['multiply','screen','overlay','color','source-over','lighter'].forEach(m=>{
      try{ testCtx.globalCompositeOperation = m; BLEND_SUPPORT[m] = (testCtx.globalCompositeOperation === m); }
      catch(_){ BLEND_SUPPORT[m] = false; }
    });
    function resolveBlendMode(requested){
      if (BLEND_SUPPORT[requested]) return requested;
      if (requested === 'color') return BLEND_SUPPORT['multiply'] ? 'multiply' : 'source-over';
      if (requested === 'overlay') return BLEND_SUPPORT['multiply'] ? 'multiply' : 'source-over';
      if (requested === 'screen') return BLEND_SUPPORT['lighter'] ? 'lighter' : 'source-over';
      return 'source-over';
    }

    const LEFT_IRIS_RING = [468,469,470,471];
    const LEFT_IRIS_CENTER = 472;
    const RIGHT_IRIS_RING = [473,474,475,476];
    const RIGHT_IRIS_CENTER = 477;
    const LEFT_EYE_UPPER = [159,158,157,173,133];
    const LEFT_EYE_LOWER = [145,144,163,7,33];
    const RIGHT_EYE_UPPER = [386,385,384,398,263];
    const RIGHT_EYE_LOWER = [374,380,381,382,362];

    function setStatus(msg, isOk = null) {
      statusEl.textContent = msg || '';
      statusEl.className = 'efw-status efw-small';
      if (isOk === true)  statusEl.className += ' efw-status-ok';
      if (isOk === false) statusEl.className += ' efw-status-bad';
    }
    function setLoadingStatus(msg) {
      statusEl.innerHTML = msg + ' <span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span>';
      statusEl.className = 'efw-status efw-small';
    }
    function isSecureContext() {
      return location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    }
    function updateCanvasSize() {
      const w = video.videoWidth || 640;
      const h = video.videoHeight || 480;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
      }
    }

    function fract(x){ return x - Math.floor(x); }
    function prand(seed){ return fract(Math.sin(seed*12.9898)*43758.5453); }

    // Blink/openness helpers
    function dist(a,b){ return Math.hypot(a.x - b.x, a.y - b.y); }
    function pt(L,i){ return { x: L[i].x * canvas.width, y: L[i].y * canvas.height }; }
    function clamp01(x){ return x < 0 ? 0 : (x > 1 ? 1 : x); }
    function leftOpenness(L){
      const up=L[159], low=L[145], l=L[33], r=L[133];
      if(!up||!low||!l||!r) return 1; //fallback â€“ ×¢×“×™×£ ×œ× ×œ×›×‘×•×ª ××¡×š ×‘××§×¨×” ××™×“×¢ ×—×¡×¨
      return clamp01( dist(pt(L,159),pt(L,145)) / Math.max(1, dist(pt(L,33),pt(L,133))) );
    }
    function rightOpenness(L){
      const up=L[386], low=L[374], l=L[263], r=L[362];
      if(!up||!low||!l||!r) return 1;
      return clamp01( dist(pt(L,386),pt(L,374)) / Math.max(1, dist(pt(L,263),pt(L,362))) );
    }
    function smoothstep(a,b,x){ const t = Math.max(0, Math.min(1, (x - a)/(b - a))); return t*t*(3-2*t); }

    function calculateEyeCenter(landmarks, ringIndices, centerIdx) {
      const W = canvas.width, H = canvas.height;
      if (Number.isInteger(centerIdx) && landmarks[centerIdx]) {
        return { x: landmarks[centerIdx].x * W, y: landmarks[centerIdx].y * H };
      }
      let sumX = 0, sumY = 0, n = 0;
      for (const idx of ringIndices) {
        const p = landmarks[idx]; if (!p) continue;
        sumX += p.x * W; sumY += p.y * H; n++;
      }
      return { x: sumX / Math.max(1,n), y: sumY / Math.max(1,n) };
    }

    function calculateEyeRadius(center, landmarks, ringIndices) {
      let total = 0, n = 0, minD = Infinity;
      for (const idx of ringIndices) {
        const p = landmarks[idx]; if (!p) continue;
        const px = p.x * canvas.width, py = p.y * canvas.height;
        const d = Math.hypot(px - center.x, py - center.y);
        total += d; n++; if (d < minD) minD = d;
      }
      const avgRadius = total / Math.max(1,n);
      const safeByRing = isFinite(minD) ? (minD * REALISM.RING_MARGIN) : avgRadius;
      const base = Math.min(avgRadius * REALISM.SIZE_MULTIPLIER, safeByRing);
      return Math.max(REALISM.MIN_RADIUS, Math.min(REALISM.MAX_RADIUS, base));
    }

    function biasEyeCenter(centerRaw, radius, ringIndices, landmarks){
      let ax=0, ay=0, n=0;
      for (const idx of ringIndices){
        const p = landmarks[idx]; if (!p) continue;
        ax += p.x * canvas.width; ay += p.y * canvas.height; n++;
      }
      if (n>0){
        const avg = { x: ax/n, y: ay/n };
        const t = Math.max(0, Math.min(1, REALISM.CENTER_BLEND));
        centerRaw = { x: centerRaw.x + (avg.x - centerRaw.x)*t, y: centerRaw.y + (avg.y - centerRaw.y)*t };
      }
      const dy = (REALISM.CENTER_Y_OFFSET||0) * (radius||0);
      return { x: centerRaw.x, y: centerRaw.y + dy };
    }

    function calculateChinPoint(landmarks){
      const p = landmarks[152];
      if (!p) return null;
      return { x: p.x * canvas.width, y: p.y * canvas.height };
    }
    function drawLogo(chin, eyes){
      if (!chin) return;
      let distPx = null;
      if (eyes && eyes.left && eyes.right){
        const dx = eyes.right.center.x - eyes.left.center.x;
        const dy = eyes.right.center.y - eyes.left.center.y;
        distPx = Math.hypot(dx, dy);
      }
      if (!distPx && eyes && eyes.left){ distPx = eyes.left.radius * 4; }
      if (!distPx) distPx = canvas.width * 0.12;

      const fontSize = Math.max(BRAND.minFont, Math.min(BRAND.maxFont, distPx * 0.35));
      const x = chin.x;
      const y = chin.y + (distPx * BRAND.offsetYFactor);

      ctx.save();
      ctx.globalAlpha = BRAND.alpha;
      ctx.font = '600 ' + fontSize + 'px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = BRAND.shadowBlur;
      ctx.lineWidth = BRAND.strokeWidth;
      ctx.strokeStyle = BRAND.stroke;
      ctx.strokeText(BRAND.text, x, y);
      ctx.fillStyle = BRAND.fill;
      ctx.fillText(BRAND.text, x, y);
      ctx.restore();
    }

    function ptsFromIndices(landmarks, indices){
      const W = canvas.width, H = canvas.height;
      const pts = [];
      for (const i of indices){
        const p = landmarks[i];
        if (p) pts.push({x: p.x*W, y: p.y*H});
      }
      return pts;
    }
    function buildEyeClip(landmarks, upperIdx, lowerIdx){
      const up = ptsFromIndices(landmarks, upperIdx);
      const low = ptsFromIndices(landmarks, lowerIdx);
      if (up.length < 2 || low.length < 2) return null;
      return up.concat([...low].reverse());
    }
    function getEyeSide(center){
      if (!currentEyes.left && !currentEyes.right) return null;
      const dl = currentEyes.left ? Math.hypot(center.x-currentEyes.left.center.x, center.y-currentEyes.left.center.y) : Infinity;
      const dr = currentEyes.right? Math.hypot(center.x-currentEyes.right.center.x, center.y-currentEyes.right.center.y) : Infinity;
      return (dl <= dr) ? 'left' : 'right';
    }
    function smoothPoly(prev, next){
      if (!next) return null;
      if (!prev) return next;
      const t = 1 - REALISM.SMOOTHING;
      const m = Math.min(prev.length, next.length);
      const out = [];
      for (let i=0; i<m; i++){
        const a = prev[i], b = next[i];
        out.push({ x: a.x + (b.x - a.x)*t, y: a.y + (b.y - a.y)*t });
      }
      for (let i=m; i<next.length; i++) out.push(next[i]);
      return out;
    }

    function paintEye(center, radius, color, alpha, blendMode) {
      if (!center || !radius || radius < 3) return;
      const r = Math.max(REALISM.MIN_RADIUS, Math.min(REALISM.MAX_RADIUS, radius * REALISM.IRIS_SHRINK));
      const S = Math.ceil(r*2 + 4);
      ensureEyeLayersSize(S);

      (function drawColor(){
        const cx = eyeColorCtx;
        cx.save();
        cx.clearRect(0,0,S,S);
        cx.translate(S/2, S/2);
        cx.beginPath(); cx.arc(0,0,r,0,Math.PI*2); cx.closePath(); cx.clip();
        cx.globalCompositeOperation = 'source-over';
        cx.globalAlpha = Math.min(1, alpha);
        cx.fillStyle = color;
        cx.fillRect(-r, -r, r*2, r*2);
        cx.globalCompositeOperation = 'destination-out';
        cx.globalAlpha = 1;
        cx.beginPath(); cx.arc(0,0, Math.max(2, r*REALISM.PUPIL_RATIO), 0, Math.PI*2); cx.fill();
        cx.restore();
      })();

      (function drawShading(){
        const sx = eyeShadeCtx;
        sx.save();
        sx.clearRect(0,0,S,S);
        sx.translate(S/2, S/2);
        sx.beginPath(); sx.arc(0,0,r,0,Math.PI*2); sx.closePath(); sx.clip();

        sx.globalCompositeOperation = 'source-over';
        sx.globalAlpha = REALISM.EDGE_DARKEN * alpha;
        let g = sx.createRadialGradient(0,0, r*0.2, 0,0, r);
        g.addColorStop(0, 'rgba(0,0,0,0)');
        g.addColorStop(1, 'rgba(0,0,0,1)');
        sx.fillStyle = g;
        sx.beginPath(); sx.arc(0,0,r,0,Math.PI*2); sx.fill();

        sx.globalAlpha = REALISM.INNER_GLOW * alpha;
        g = sx.createRadialGradient(0,0, 0, 0,0, r*0.65);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        sx.fillStyle = g;
        sx.beginPath(); sx.arc(0,0,r,0,Math.PI*2); sx.fill();

        sx.globalAlpha = REALISM.LIMBAL_ALPHA * alpha;
        sx.beginPath();
        sx.arc(0,0,r,0,Math.PI*2);
        sx.lineWidth = Math.max(1, r * REALISM.LIMBAL_WIDTH);
        sx.lineCap = 'round'; sx.lineJoin = 'round';
        sx.strokeStyle = 'rgba(0,0,0,1)';
        sx.stroke();

        sx.globalAlpha = REALISM.FIBER_ALPHA * alpha;
        sx.lineCap = 'round';
        for (let i=0; i<REALISM.FIBER_COUNT; i++){
          const jitter = (prand(100+i)-0.5) * REALISM.FIBER_JITTER;
          const a = (i / REALISM.FIBER_COUNT) * Math.PI*2 + jitter;
          const inner = r * REALISM.FIBER_INNER;
          const outer = r * REALISM.FIBER_OUTER;
          const x1 = Math.cos(a)*inner, y1 = Math.sin(a)*inner;
          const x2 = Math.cos(a)*outer, y2 = Math.sin(a)*outer;
          sx.beginPath(); sx.moveTo(x1,y1); sx.lineTo(x2,y2);
          sx.lineWidth = 1; sx.strokeStyle = 'rgba(0,0,0,1)'; sx.stroke();
        }

        sx.globalCompositeOperation = 'screen';
        sx.globalAlpha = REALISM.FIBER_LIGHT_ALPHA * alpha;
        sx.lineCap = 'round';
        for (let i=0; i<REALISM.FIBER_COUNT; i++){
          const jitter = (prand(1000+i)-0.5) * REALISM.FIBER_JITTER;
          const a = (i / REALISM.FIBER_COUNT) * Math.PI*2 + jitter;
          const inner = r * 0.252;
          const outer = r * 0.931;
          const x1 = Math.cos(a)*inner, y1 = Math.sin(a)*inner;
          const x2 = Math.cos(a)*outer, y2 = Math.sin(a)*outer;
          sx.beginPath(); sx.moveTo(x1,y1); sx.lineTo(x2,y2);
          sx.lineWidth = 0.8; sx.strokeStyle = 'rgba(255,255,255,1)'; sx.stroke();
        }

        sx.globalCompositeOperation = 'overlay';
        sx.globalAlpha = REALISM.BAND_ALPHA * alpha;
        for (let b=1; b<=REALISM.BAND_COUNT; b++){
          const t = b/(REALISM.BAND_COUNT+1);
          sx.beginPath();
          sx.arc(0,0, r*(0.35 + t*0.55), 0, Math.PI*2);
          sx.lineWidth = 1; sx.strokeStyle = 'rgba(0,0,0,1)'; sx.stroke();
        }

        sx.globalAlpha = REALISM.HIGHLIGHT_ALPHA * alpha;
        const hlr = r * 0.5;
        const hx = - r*REALISM.HIGHLIGHT_OFFSET;
        const hy = - r*REALISM.HIGHLIGHT_OFFSET;
        const grad = sx.createRadialGradient(hx, hy, hlr*0.05, hx, hy, hlr);
        grad.addColorStop(0, 'rgba(255,255,255,0.9)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        sx.fillStyle = grad;
        sx.beginPath(); sx.arc(0,0,r,0,Math.PI*2); sx.fill();

        sx.globalAlpha = 0.06 * alpha;
        sx.fillStyle = sx.createPattern(noiseCanvas, 'repeat');
        sx.fillRect(-r, -r, r*2, r*2);

        sx.globalCompositeOperation = 'destination-out';
        sx.globalAlpha = 1;
        sx.beginPath(); sx.arc(0,0, Math.max(2, r*REALISM.PUPIL_RATIO), 0, Math.PI*2); sx.fill();
        sx.restore();
      })();

      const sideForMask = getEyeSide(center);
      const lidPoly = sideForMask && currentEyelids[sideForMask] ? currentEyelids[sideForMask] : null;
      ensureMaskSize(S);
      (function buildMask(){
        eyeMaskCtx.save();
        eyeMaskCtx.clearRect(0,0,S,S);
        eyeMaskCtx.translate(S/2, S/2);
        eyeMaskCtx.beginPath(); eyeMaskCtx.arc(0,0,r,0,Math.PI*2);
        eyeMaskCtx.fillStyle='rgba(255,255,255,1)'; eyeMaskCtx.fill();
        eyeMaskCtx.restore();

        if (EYELID_MASK.ENABLED && lidPoly && lidPoly.length >= 3){
          eyeCutCtx.save();
          eyeCutCtx.clearRect(0,0,S,S);
          eyeCutCtx.translate(S/2, S/2);
          eyeCutCtx.fillStyle = 'rgba(255,255,255,1)';
          eyeCutCtx.fillRect(-S/2, -S/2, S, S);
          eyeCutCtx.globalCompositeOperation = 'destination-out';
          eyeCutCtx.beginPath();
          eyeCutCtx.moveTo(lidPoly[0].x - center.x, lidPoly[0].y - center.y);
          for (let i=1;i<lidPoly.length;i++){
            const p = lidPoly[i];
            eyeCutCtx.lineTo(p.x - center.x, p.y - center.y);
          }
          eyeCutCtx.closePath();
          eyeCutCtx.fill();
          eyeCutCtx.restore();

          eyeCutFeatherCtx.save();
          eyeCutFeatherCtx.clearRect(0,0,S,S);
          try { eyeCutFeatherCtx.filter = `blur(${EYELID_MASK.BLUR_PX}px)`; } catch(_) {}
          eyeCutFeatherCtx.drawImage(eyeCutLayer, 0, 0);
          try { eyeCutFeatherCtx.filter = 'none'; } catch(_) {}
          eyeCutFeatherCtx.restore();

          eyeMaskCtx.save();
          eyeMaskCtx.globalCompositeOperation = 'destination-out';
          eyeMaskCtx.globalAlpha = Math.max(0, Math.min(1, EYELID_MASK.CLIP_STRENGTH));
          eyeMaskCtx.drawImage(eyeCutFeather, 0, 0);
          eyeMaskCtx.restore();
        }

        eyeMaskFeatherCtx.save();
        eyeMaskFeatherCtx.clearRect(0,0,S,S);
        try { eyeMaskFeatherCtx.filter = 'blur(1.2px)'; } catch(_) {}
        eyeMaskFeatherCtx.drawImage(eyeMaskLayer, 0, 0);
        try { eyeMaskFeatherCtx.filter = 'none'; } catch(_) {}
        eyeMaskFeatherCtx.restore();
      })();

      eyeColorCtx.globalCompositeOperation = 'destination-in';
      eyeColorCtx.drawImage(eyeMaskFeather, 0, 0);
      eyeShadeCtx.globalCompositeOperation = 'destination-in';
      eyeShadeCtx.drawImage(eyeMaskFeather, 0, 0);

      ctx.save();
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = resolveBlendMode(blendMode);
      ctx.drawImage(eyeColorLayer, center.x - S/2, center.y - S/2);

      ctx.globalCompositeOperation = resolveBlendMode('screen');
      ctx.globalAlpha = REALISM.FILL_BOOST_ALPHA * alpha;
      ctx.drawImage(eyeColorLayer, center.x - S/2, center.y - S/2);

      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = resolveBlendMode('overlay');
      ctx.drawImage(eyeShadeLayer, center.x - S/2, center.y - S/2);
      ctx.restore();
    }

    function onFaceMeshResults(results) {
      if (!results.multiFaceLandmarks || !results.multiFaceLandmarks.length) {
        currentEyes = { left: null, right: null };
        facesEl.textContent = '0';
        return;
      }
      facesEl.textContent = results.multiFaceLandmarks.length;
      const landmarks = results.multiFaceLandmarks[0];

      const openL = leftOpenness(landmarks);
      const openR = rightOpenness(landmarks);

      const leftRawPoly  = buildEyeClip(landmarks, LEFT_EYE_UPPER, LEFT_EYE_LOWER);
      const rightRawPoly = buildEyeClip(landmarks, RIGHT_EYE_UPPER, RIGHT_EYE_LOWER);
      currentEyelids.left  = smoothPoly(currentEyelids.left,  leftRawPoly);
      currentEyelids.right = smoothPoly(currentEyelids.right, rightRawPoly);

      const chinRaw = calculateChinPoint(landmarks);
      const lerp = (a,b,t)=> a + (b-a)*t;
      const smoothPt = (prev,next)=> !prev? next : { x: lerp(prev.x, next.x, 1-REALISM.SMOOTHING), y: lerp(prev.y, next.y, 1-REALISM.SMOOTHING)};
      if (chinRaw) { currentLogo = smoothPt(currentLogo, chinRaw); }

      const leftCenterRaw  = calculateEyeCenter(landmarks, LEFT_IRIS_RING, LEFT_IRIS_CENTER);
      const leftRadiusRaw  = calculateEyeRadius(leftCenterRaw, landmarks, LEFT_IRIS_RING);
      const rightCenterRaw = calculateEyeCenter(landmarks, RIGHT_IRIS_RING, RIGHT_IRIS_CENTER);
      const rightRadiusRaw = calculateEyeRadius(rightCenterRaw, landmarks, RIGHT_IRIS_RING);

      function smooth(prev, next){
        if (!prev) return next;
        const t = 1 - REALISM.SMOOTHING;
        return {
          center: { x: lerp(prev.center.x, next.center.x, t), y: lerp(prev.center.y, next.center.y, t) },
          radius: lerp(prev.radius, next.radius, t),
          open:   clamp01((prev.open ?? next.open ?? 0) + ((next.open ?? 0) - (prev.open ?? 0)) * t)
        };
      }

      const leftCenter = biasEyeCenter(leftCenterRaw, leftRadiusRaw, LEFT_IRIS_RING, landmarks);
      const rightCenter = biasEyeCenter(rightCenterRaw, rightRadiusRaw, RIGHT_IRIS_RING, landmarks);
      const leftNext  = { center: leftCenter,  radius: leftRadiusRaw,  open: openL };
      const rightNext = { center: rightCenter, radius: rightRadiusRaw, open: openR };
      currentEyes = {
        left:  currentEyes.left  ? smooth(currentEyes.left,  leftNext)  : leftNext,
        right: currentEyes.right ? smooth(currentEyes.right, rightNext) : rightNext
      };
    }

    async function processVideoFrame() {
      if (!running || !video.videoWidth || !video.videoHeight) {
        if (running) animationId = requestAnimationFrame(processVideoFrame);
        return;
      }

      const now = performance.now();
      frameCount++;
      if (!lastTime) lastTime = now;
      if (now - lastTime >= 1000) {
        fpsCounter = Math.round((frameCount * 1000) / (now - lastTime));
        fpsEl.textContent = fpsCounter;
        frameCount = 0; lastTime = now;
      }

      updateCanvasSize();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if (faceMesh) {
        try { await faceMesh.send({ image: video }); } catch (_) {}
      }

      const alpha = parseInt(alphaInp.value, 10) / 100;
      const color = colorInp.value;
      const blendMode = blendSel.value;

      if (alpha > 0 && currentEyes) {
        const gateL = currentEyes.left  ? smoothstep(BLINK.T0, BLINK.T1, (currentEyes.left.open  ?? 0))  : 0;
        const gateR = currentEyes.right ? smoothstep(BLINK.T0, BLINK.T1, (currentEyes.right.open ?? 0)) : 0;
        const alphaL = alpha * gateL;
        const alphaR = alpha * gateR;
        if (alphaL > 0.01 && leftChk.checked  && currentEyes.left)  paintEye(currentEyes.left.center,  currentEyes.left.radius,  color, alphaL, blendMode);
        if (alphaR > 0.01 && rightChk.checked && currentEyes.right) paintEye(currentEyes.right.center, currentEyes.right.radius, color, alphaR, blendMode);
      }

      drawLogo(currentLogo, currentEyes);
      if (running) animationId = requestAnimationFrame(processVideoFrame);
    }

    async function initializeFaceMesh() {
      try {
        setLoadingStatus('×××ª×—×œ ×–×™×”×•×™ ×¤× ×™×');
        if (typeof FaceMesh === 'undefined') throw new Error('MediaPipe FaceMesh ×œ× × ×˜×¢×Ÿ');

        faceMesh = new FaceMesh({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
          maxNumFaces: 1,
          refineLandmarks: true,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5
        });

        faceMesh.onResults(onFaceMeshResults);
        if (typeof faceMesh.initialize === 'function') await faceMesh.initialize();

        helpEl.textContent = '×–×™×”×•×™ ×¤× ×™× ××•×›×Ÿ (MediaPipe FaceMesh)';
        return true;
      } catch (error) {
        setStatus('×©×’×™××” ×‘××ª×—×•×œ ×–×™×”×•×™ ×¤× ×™×: ' + (error.message || error), false);
        return false;
      }
    }

    async function startCamera() {
      try {
        if (!isSecureContext()) { setStatus('×“×¨×•×© HTTPS ××• localhost ×œ×’×™×©×” ×œ××¦×œ××”', false); return; }
        if (!navigator.mediaDevices?.getUserMedia) { setStatus('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×’×™×©×” ×œ××¦×œ××”', false); return; }

        btnStart.disabled = true;
        setLoadingStatus('××‘×§×© ×’×™×©×” ×œ××¦×œ××”');

        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'user',
            width:  { ideal: 640, max: 1280 },
            height: { ideal: 480, max: 720 },
            frameRate: { ideal: 30, max: 60 }
          },
          audio: false
        });

        video.srcObject = stream;
        await new Promise((resolve, reject) => {
          video.onloadedmetadata = resolve;
          video.onerror = reject;
          setTimeout(() => reject(new Error('Timeout loading video')), 10000);
        });
        await video.play();

        const ok = await initializeFaceMesh();
        if (!ok) throw new Error('Failed to initialize FaceMesh');

        running = true;
        lastTime = performance.now();
        frameCount = 0;

        btnStart.disabled = false;
        btnStop.disabled = false;

        setStatus('×”××¦×œ××” ×¤×•×¢×œ×ª - ×–×™×”×•×™ ×¤× ×™× ×¤×¢×™×œ', true);
        processVideoFrame();

      } catch (error) {
        let msg = '×©×’×™××” ×‘×”×¤×¢×œ×ª ×”××¦×œ××”: ';
        if (error.name === 'NotAllowedError') msg += '×”×¨×©××” × ×“×—×ª×” - ×™×© ×œ××¤×©×¨ ×’×™×©×” ×œ××¦×œ××”';
        else if (error.name === 'NotFoundError') msg += '××¦×œ××” ×œ× × ××¦××” ×‘××›×©×™×¨';
        else if (error.name === 'NotReadableError') msg += '×”××¦×œ××” ×‘×©×™××•×© ××• ×œ× ×–××™× ×”';
        else msg += (error.message || '×©×’×™××” ×œ× ×™×“×•×¢×”');

        setStatus(msg, false);
        btnStart.disabled = false;
        if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
        running = false;
      }
    }

    function stopCamera() {
      try {
        running = false;
        if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
        if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
        video.srcObject = null;
        currentEyes = { left: null, right: null };
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        btnStart.disabled = false;
        btnStop.disabled = true;
        fpsEl.textContent = '0';
        facesEl.textContent = '0';
        setStatus('×”××¦×œ××” × ×¢×¦×¨×”');
      } catch (_) {}
    }

    btnStart.addEventListener('click', startCamera);
    btnStop.addEventListener('click', stopCamera);
    colorInp.addEventListener('input', () => {
      document.querySelectorAll('.efw-chip').forEach(c => c.classList.remove('active'));
    });
    document.querySelectorAll('.efw-chip').forEach(chip => {
      chip.addEventListener('click', () => {
        colorInp.value = chip.dataset.color;
        document.querySelectorAll('.efw-chip').forEach(c => c.classList.remove('active'));
        chip.classList.add('active');
      });
    });
    alphaInp.addEventListener('input', () => { alphaVal.textContent = alphaInp.value; });
  })();
  </script>
</div>
</body>
</html>
